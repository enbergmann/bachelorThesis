\section{Hinweise zur Benutzung des Programms}
%\subsection{Aufbau des Programms}
Ziel der für diese Arbeit implementierten Methoden ist die Realisierung von
\Cref{alg:primalDualIteration} im Solve-Schritt des AFEM-Algorithmus aus
\Cref{fig:afemLoop}. 
Wir gehen davon aus, dass dieser und die im
AFEM-Softwarepaket realisierten Methoden sowie deren Datenstrukturen bekannt
sind und verweisen für weitere Details auf \cite{CGKNRR10}. 
Im Refine-Schritt nutzten wir anstelle eines Fehlerschätzers den
Verfeinerungsindikator aus \Cref{def:refinementIndicator}.

\begin{figure}[h]
  \centering
  \input{pictures/chapImplementation/afemloop.tex}
  \caption{AFEM-Schleife}
  \label{fig:afemLoop}
\end{figure}

Die zur korrekten Funktionsweise dieses Programms nötigen Methoden und
Dateien des AFEM-Softwarepakets sind enthalten im Ordner
\texttt{./utils/afemPackage/} sowie \texttt{./utils/geometries/}.

Alle Ein- und Ausgabeparameter der im Rahmen dieser Arbeit implementierten
Methoden sind in den entsprechenden Dateien detailiert dokumentiert. 
Ausgenommen davon sind die Standard-Datenstrukturen aus dem AFEM-Softwarepaket,
die dort lediglich namentlich genannt werden.
Die mathematischen Grundlagen für die Realisierung einiger Methoden diskutieren
wir in \Cref{sec:mathematicalBasicsForMethods}.

Die ausführbare Methode, welche den AFEM-Algorithmus realisiert, ist
\begin{center}
  \texttt{./nonconforming/startAlgorithmCR.m}.
\end{center}
Als optionaler Eingabeparameter ist dabei ein String \texttt{benchmark}
möglich. 
Wird die Methode ohne Übergabe eines solchen Parameters ausgeführt, nutzt
sie als Standardwert \texttt{benchmark = 'editable'}.
Nach Ausführen von \texttt{startAlgorithmCR(benchmark)} werden die nötigen
Parameter und Einstellungen für das jeweilige Experiment aus der Datei
\begin{center}
  \texttt{./nonconforming/benchmarks/benchmark.m}
\end{center}
geladen und als Felder des Structure Arrays \texttt{params} übergeben. Für
jedes in dieser Arbeit dokumentierte Experiment verweisen wir in
\Cref{chap:experiments} an entsprechender Stelle auf das dafür benutzte 
Benchmark, welches in \texttt{./nonconforming/benchmarks/} zu finden ist und
somit die Reproduzierbarkeit des Experiments garantiert. 
Als Muster für eine Bechmark-Datei dient
\begin{center}
  \texttt{./nonconforming/benchmarks/editable.m}.
\end{center}
Eine Übersicht über die wählbaren Parameter in einer Benchmark-Datei ist
zu finden in den Tabellen \ref{tab:paramsAFEM}, \ref{tab:paramsAFEM}, \ldots
und \ref{tab:paramsAFEM}. 
Weitere Details zu den Datentypen sind in \texttt{editable.m} zu finden.
\todo{alle Benchmark einstellungen hier in einer Tabelle auflisten und
dokumentieren? Wahrscheinlich ja, so kann dokumentiert werden, dass zB 
Prolongation möglich ist. ``Alle Einstellungen und Paramter dokumentieren wir
in Abschnitt \ldots''/,,Die Einstellungen dokumentieren wir in den Tabellen
\ldots``. Dort kann dann auch, vlt auch erst wenn CC das will,
gesagt werden zB sowas wie prolongiert wird}

Dass die zahlreichen Parameter, die während des Pro\-gramm\-ab\-laufs
über- oder ausgegeben werden müssen, als Felder von
Struc\-ture Ar\-rays gespeichert werden, dient der Modifizierbarkeit des
Programms. 
So haben Korrekturen und Ergänzungen am Programm häufig nur zur Folge, dass
einige \texttt{structs} um Felder ergänzt werden müssen während die 
Methodenköpfe unverändert bleiben können.

Das Eingangssignal $f$ und eventuell weitere Funktionen, wie etwa die exakte
Lösung $u$ von \Cref{prob:continuousProblem} und ihre schwache Ableitung
$\nabla u$, müssen in der Benchmark-Datei angegeben werden um sie dem
Programm zu übergeben. 
Die für die Experimente in \Cref{chap:experiments} genutzten Funktionen sind zu
finden in 
\begin{center}
  \texttt{./utils/functions/}.
\end{center}

Ist eine Lösung $u$ von $\Cref{prob:continuousProblem}$ bekannt, so kann die
exakte Energie $E(u)$ approximiert werden mit der Methode
\begin{center}
  \texttt{./nonconforming/computeExactEnergyBV.m}.
\end{center}
Die so berechneten Energien werden gespeichert in 
\begin{center}
  \texttt{./nonconforming/knownExactEnergies/}
\end{center}
und können anschließend manuell in ein Benchmark aufgenommen werden.
\todo{$f=\alpha g$ und weiter Details zur Umwandlung von Bildern? Hier oder
bei Details zu ausgewählten Funktionen?}

Soll als Eingangssignal kein \texttt{function\_handle} sondern ein
Graufarbenbild gegeben werden, so muss es gespeichert sein in 
\begin{center}
  \texttt{./utils/functions/images/}.
\end{center}
Um Dirichlet-Nullranddaten des Bildes zu garantierten, was einem schwarzen Rand
entspricht, kann die Methode 
\begin{center}
  \texttt{./utils/functions/images/addBoundary2image.m}
\end{center}
genutzt werden. Diese fügt einen graduellen Übergang zu schwarzen Rand auf den 
äußeren 25 Pixeln des Bildes hinzu.

Um additives weißes gaußsches Rauschen zu einen Bild hinzuzufügen, kann die
Methode
\begin{center}
  \texttt{./utils/functions/images/addNoise2image.m}
\end{center}
genutzt werden. 

Eine Ausführung des Programms, bei der alle relevanten Methoden gebraucht
werden, verläuft wie folgt. 
Im Benchmark müssen die exakte Lösung $u\in H^1_0(\Omega)$, die schwachen
Gradienten von $u$ und $f\in H^1_0(\Omega)$ und die exakte Energie
$E(u)$ gegeben sein. 
Außerdem müssen einige Paramter wie folgt gewählt werden.
\begin{itemize}
  \item \texttt{useExactEnergy = true}
  \item \texttt{useImage = false}
  \item \texttt{rhsGradientKnown = true}
  \item \texttt{exactSolutionKnown = true}
  \item \texttt{useExactEnergy = true}
\end{itemize}
Noch in der Benchmark-Datei werden mit den gewählten Einstellungen die
benötigten geometrischen Datenstrukturen initialisiert. 
Diese werden mit 
allen weiteren Informationen als Felder eines Structure Arrays
gespeichert und an \texttt{startAlgorithmCR} übergeben. 
Anschließend werden Structure Arrays mit Feldern für die benötigten Daten
während der AFEM-Routine sowie deren Ergebnisse erstellt. 
Nach dem Berechnen einiger weiterer Informationen beginnt die AFEM-Schleife.

Zu Beginn der Schleife werden die für das aktuelle Level benötigten Daten
ermittelt, zum Beispiel die Flächen der Dreiecke und die Freiheitsgrade der
aktuellen Triangulierung. 
Insbesondere werden die Gradienten der lokalen
Crouzeix-Raviart-Basisfunktionen auf den Dreiecken in
\begin{center}
  \texttt{./nonconforming/common/computeGradsCR4e.m}
\end{center}
sowie damit der nichtkonforme Gradient des aktuellen Iterats in
\begin{center}
  \texttt{./nonconforming/common/gradientCR.m}
\end{center}
und die Crouzeix-Raviart-Steifigkeits- und Massematrix 
\begin{center}
  \texttt{./nonconforming/common/computeFeMatricesCR.m}
\end{center}
berechnet. 

Codezeile ca 115


als Kompromiss zwischen Performance und Genauigkeit.


\ldots
(Ende von PB Realisierung Chapter artig hier was schreiben, auch integrate
entsprechend erwähnen)
Insbesondere erwähnen, wenn Terme die öfter gebraucht berechnet werden und
bei Bedarf auf die folgenden Sections verweisen, in denen mathematische
Grundlagen erklärt werden.

%\bigskip
%%%%%%%%%%%%%%%%%%%%%%%%%%
%cd Realisierungschapter PB
%
%Tabelle 4.2 (PB) artige Übersicht über die benutzten AFEM 
%Datenstrukturen, die im Programm nicht extra dokumentiert wurden. Für alle
%anderen In- und Outputs verweise auf Dokumentation in den Docstrings
%
%
%
%Die Ausführbare Funktionen werden im nächsten Kapitel beschrieben.
%
%%\subsection{Erstellen eines lauffähigen Benchmarks (Minimalbeispeil)}
%Beschreibung der wichtigsten Parameter
%und Idee hinter structs
%
%Ordner, in denen die Funktionen für rechte Seite, Gradient, exakte
%Lösung etc liegen müsssen
%
%Wahrscheinlich flag für flag durchgehen, erklären, welche automatisch gesetzt 
%werden u.U., und wann immer nötig sagen, was man vorher machen muss, wo man
%Funktionen erstellen muss etc.
%
%fur exakte Lösungs Beispiel usw.
%Berechnung der exakten Energie, also alles was nur mehr Möglichkeiten bietet,
%Verweis auf die nächste Section (in der dann sagen, welche Flags gesetzt werden 
%können)
%
%
%\subsubsection{\texttt{startAlgorithmCR.m}}
%\texttt{test}
%\subsubsection{\texttt{computeExactEnergyBV.m}}
%\subsubsection{\texttt{addNoise2image.m}}
%\subsubsection{\texttt{addBoundary2image.m}}

\begin{table}
  \centering
  \begin{tabular}{c|p{9cm}}
    \hline
    Parametername  & Beschreibung\\  
    \hline
    \texttt{geometry} &
    Name der Geometrie auf deren Triangulierung der AFEM-Algorithmus
    angewendet werden soll 
    \newline(cf. \texttt{loadGeometry} in \cite{CGKNRR10})\\
    \texttt{initialRefinementLevel} &
    Anzahl der Rotverfeinerungen die auf die Triangulierung der Geometrie
    \texttt{geometry} angewendet werden sollen vor Start des AFEM\--Algorithmus 
    \newline(cf. \texttt{loadGeometry} in \cite{CGKNRR10})\\
    \texttt{parTheta}& Bulk-Parameter $\theta$ für den Mark-Schritt des
    AFEM-Algorithmus ($\theta\in(0,1)$ für adaptive und $\theta=1$ für uniforme
    Netzverfeinerung)\\
    \texttt{minNrDof}& 
    Anzahl der Freiheitsgrade der Triangulierung eines Levels, die mindestens
    erreicht werden soll, bevor der AFEM-Algorithmus abbricht\\
    \texttt{useProlongation}&
    \texttt{true}, wenn eine Prolongation der Lösung der pri\-ma\-len-dualen 
    Iteration als Startwert für die Iteration des nächsten Levels genutzt
    werden soll, sonst \texttt{false}\\
    \texttt{beta4Estimate}& 
    Paramter $\gamma$ aus \Cref{def:refinementIndicator}\\
    \texttt{n4Estimate}& 
    Parameter $d$ aus \Cref{def:refinementIndicator}\\
    \hline
  \end{tabular}
  \caption{Parameter für den AFEM-Algorithmus}
  \label{tab:paramsAFEM}
\end{table} 


\section{Erstellen einer Benchmark-Datei}
Vielleicht (das heißt wahrscheinlich) in der 'Hinweise' Section in einer
Tabelle ala PB Realisierungstabelle. Tabellen vlt trennen nach Art der paramter
(AFEM Params, Exp Params, Funktionen, misc usw.)
Beispielhaft für eine der Paramter Arten machen um Tien fragen zu können

Datentypen weglassen mit Verweis auf Details in editable?
  %\begin{tabular}{c||p{4cm}|p{5cm}}
  %  \hline
  %  Parametername & Datentypen & Beschreibung\\  
  %  \hline
  %  \texttt{geometry} &
  %  \texttt{string} /\newline einzeiliges \texttt{char array} 
  %  & Name der Geometrie auf deren Triangulierung der AFEM-Algorithmus
  %  angewendet werden soll 
  %  \newline(cf. \texttt{loadGeometry} 
  %  \newline
  %  in \cite{CGKNRR10})\\
  %  \texttt{initialRefinementLevel} 
  %  &\texttt{uint64}
  %  &Anzahl der Rotverfeinerungen 
  %  \newline(cf. \texttt{loadGeometry} 
  %  \newline in \cite{CGKNRR10})\\
  %  \texttt{parTheta}&\texttt{double}\\
  %  \texttt{minNrDof}&\texttt{uint64}\\
  %  \texttt{useProlongation}&\texttt{logical}\\
  %  \texttt{beta4Estimate}&\texttt{double}\\
  %  \texttt{n4Estimate}&\texttt{uint64}\\
  %  \hline
  %\end{tabular}

Paramter weglassen die nicht garantiert geändert werden sollen/können ohne
Anpassungen des Programms?


\section{Mathematische Grundlagen ausgewählter Methoden}
\label{sec:mathematicalBasicsForMethods}
\todo{Funktionsname in den Sections als Überschrift oder Nutzen der 
entsprechenden Methode in die Überschrift?}


\subsection{Berechnung lokaler Knotenwerte einer Crouzeix-Raviart-Funktion}

Sei $\ucr\in\CR^1(\Tcal)$.

Für die in dieser Arbeit implementierte Prolongation von $\ucr$ auf eine
Verfeinerung der Triangulierung $\Tcal$ oder für die Berechnung der $L^1$-Norm
der Kantensprünge von $\ucr$ benötigen wir für jedes Dreieck $T\in\Tcal$ die
Werte von $\ucr$ in den Knoten von $T$. 

Dazu sei $T = \conv\{P_1, P_2, P_3\}$ mit den Kanten
$E_1 = \conv\{P_1,P_2\}$, $E_2 = \conv\{P_2,P_3\}$ und $E_3 =
\conv\{P_3,P_1\}$. 
Die Funktion $u\coloneqq\ucr|_T$ habe in den Mittelpunkten der Kanten die Werte
$u_j\coloneqq u\left(\Mid(E_j)\right)$ für alle $j\in\{1,2,3\}$. 
Gesucht sind damit die Werte $u(P_1)$, $u(P_2)$ und $u(P_3)$.

Da $\ucr\in\CR^1(\Tcal)$, ist $u$ affin. Damit gilt für eine Kante
$E=\conv\{P,Q\}\in\{E_1,E_2,E_3\}$, dass $u(\Mid(E))$ gegeben ist durch den
Mittelwert von $u(P)$ und $u(Q)$.

Somit erhalten wir die drei Gleichungen
\begin{align*}
  u_1 &= \frac{u(P_1)+u(P_2)}{2},  
  &u_2 &= \frac{u(P_2)+u(P_3)}{2},  
  &u_3 &= \frac{u(P_3)+u(P_1)}{2}.
\end{align*}
Sind $u_1$, $u_2$ und $u_3$ bekannt, können wir dieses Gleichungssystem nach 
$u(P_1)$, $u(P_2)$ und $u(P_3)$ lösen und erhalten die gesuchten Werte
\begin{align*}
 u(P_1)&=u_1+u_3-u_2, &u(P_2)&= u_1+u_2-u_3,&u(P_3)&=u_2+u_3-u_1.
\end{align*}

Wir realisieren dies mit der Methode
\begin{center}
  \texttt{./nonconforming/common/computeNodeValuesCR4e.m}.
\end{center} 

\subsection{Berechnung von Sprungtermen}

Insbesondere für die Berechnung des Verfeinerungsindikators aus
\Cref{def:refinementIndicator} benötigen wir eine Methode, die
für eine Crouzeix-Raviart-Funktion
$\vcr\in\CR^1_0(\Tcal)$
%und zur Auswertung der kontinuierlichen Energie $E(\vcr)$ einer 
%Crouzeix-Raviart Funktion $\vcr$, deren diskrete Energie $\Enc(\vcr)$
%bereits bekannt ist, 
für alle Kanten $F\in\Ecal$ die Terme $\Vert [\vcr]_F\Vert_{L^1(F)}$ 
bestimmt.

Da $\vcr\in\CR^1_0(\Tcal)$, ist $[\vcr]_F$ affin und es gilt
$[\vcr]_F\big(\Mid(F)\big)=0$ für alle Kanten $F\in\Ecal$.

Betrachten wir nun eine beliebige Kante $F\in\Ecal$ mit $F=\conv\{P_1,P_2\}$. 
Wir definieren eine Parametrisierung $\xi:[0,2]\to\Rbb^2$ von $F$ durch
$\xi(t)\coloneqq \frac{t}{2}(P_2-P_1)+P_1$. 
Es gilt $\left|\xi'\right|\equiv \frac{1}{2}|P_2-P_1|=\frac{1}{2}|F|$.

Sei außerdem
$p(t)\coloneqq [\vcr]_F\big(\xi(t)\big)$. Dann gilt
\begin{align*}
  \Vert [\vcr]_F\Vert_{L^1(F)} 
  &=
  \int_F |[\vcr]_F|\ds 
  = \int_0^2 |p(t)|\left|\xi'(t)\right|\dt
  = \frac{|F|}{2}\int_0^2 |p(t)|\dt\\
  &= \frac{|F|}{2}\left(\int_0^1 |p(t)|\dt + \int_1^2 |p(t)|\dt\right).
\end{align*}

Da $\vcr\in\CR^1_0(\Tcal)$, ist $|p(\bullet)|$ auf $[0,1]$ und $[1,2]$ jeweils
ein Polynom von Grad $1$ mit $|p(1)|=\left|[\vcr]_F\big(\Mid(F)\big)\right|=0$. 
Somit können wir $|p|$ explizit ausdrücken durch
\begin{align*}
  |p(t)|&=(1-t)|p(0)| \quad\text{für alle }t\in[0,1] \quad\text{und }\\
  |p(t)|&=(t-1)|p(2)| \quad\text{für alle }t\in[1,2].
\end{align*}
Damit erhalten wir, aufgrund der Exaktheit der Mittelpunktsregel für Polynome
von Grad 1, dass
\begin{align*}
  \int_0^1 |p(t)|\dt 
  &= 
  (1-0)\left|p\left( \frac{1}{2} \right)\right|
  =
  \frac{|p(0)|}{2}\quad\text{und }\\
  \int_1^2 |p(t)|\dt 
  &= 
  (2-1)\left|p\left( \frac{3}{2} \right)\right|
  =
  \frac{|p(2)|}{2}.
\end{align*}

Insgesamt gilt also
\begin{align*}
  \left\Vert [\vcr]_F\right\Vert_{L^1(F)} 
  &=
  \frac{|F|}{2}\left(\frac{|p(0)|}{2} + \frac{|p(2)|}{2}\right)
  =
  \frac{|F|}{4}\big(|p(0)|+|p(2)|\big)\\
  &= 
  \frac{|F|}{4}\big(|[\vcr]_F(P_1)|+|[\vcr]_F(P_2)|\big),
\end{align*}
beziehungsweise 
  $\Vert [\vcr]_F\Vert_{L^1(F)} =
  \frac{|F|}{4}\big(|\vcr(P_1)|+|\vcr(P_2)|\big)$ für eine Randkanten
  $F\in\Ecal(\partial\Omega)$.

Realisiert wird dies in der Methode
\begin{center}
  \texttt{./nonconforming/common/computeL1NormOfJump4s.m}.
\end{center}
Dabei werden für $\vcr\in\CR^1_0(\Tcal)$ für jede Kante $F\in\Ecal$ mit
$F=\conv\{P_1,P_2\}$ die Terme $|[\vcr]_F(P_1)|$ und $|[\vcr]_F(P_2)|$
berechnet in
\begin{center}
  \texttt{./nonconforming/common/computeAbsNodeJumps4s.m}.
\end{center}


\subsection{Implementation der GLEB}
\begin{center}
  \texttt{./nonconforming/common/computeGleb.m}.
\end{center}

\subsection{Implementation des Refinement Indicators}

\subsection{Implementaition der exakten Energie Berechnung}


