\section{Hinweise zur Benutzung des Programms}
%\subsection{Aufbau des Programms}
Ziel der für diese Arbeit implementierten Methoden ist die Realisierung von
\Cref{alg:primalDualIteration} im Solve-Schritt des AFEM-Algorithmus aus
\Cref{fig:afemLoop}. 
Wir gehen davon aus, dass dieser und die im
AFEM-Softwarepaket realisierten Methoden sowie deren Datenstrukturen bekannt
sind und verweisen für weitere Details auf \cite{CGKNRR10}. 
Im Refine-Schritt nutzten wir anstelle eines Fehlerschätzers den
Verfeinerungsindikator aus \Cref{def:refinementIndicator}.

\begin{figure}[h]
  \centering
  \input{pictures/chapImplementation/afemloop.tex}
  \caption{AFEM-Schleife}
  \label{fig:afemLoop}
\end{figure}

Die zur korrekten Funktionsweise dieses Programms nötigen Methoden und
Dateien des AFEM-Softwarepakets sind enthalten im Ordner
\texttt{./utils/afemPackage/} sowie \texttt{./utils/geometries/}.

Alle Ein- und Ausgabeparameter der im Rahmen dieser Arbeit implementierten
Methoden sind in den entsprechenden Dateien detailiert dokumentiert. 
Ausgenommen davon sind die Standard-Datenstrukturen aus dem AFEM-Softwarepaket,
die dort lediglich namentlich genannt werden.
Die mathematischen Grundlagen für die Realisierung einiger Methoden diskutieren
wir in \Cref{sec:mathematicalBasicsForMethods}.

Die ausführbare Methode, welche den AFEM-Algorithmus realisiert, ist
\begin{center}
  \texttt{./nonconforming/startAlgorithmCR.m}.
\end{center}
Als optionaler Eingabeparameter ist dabei ein String \texttt{benchmark}
möglich. 
Wird die Methode ohne Übergabe eines solchen Parameters ausgeführt, nutzt
sie als Standardwert \texttt{benchmark = 'editable'}.
Nach Ausführen von \texttt{startAlgorithmCR(benchmark)} werden die nötigen
Parameter und Einstellungen für das jeweilige Experiment aus der Datei
\begin{center}
  \texttt{./nonconforming/benchmarks/benchmark.m}
\end{center}
geladen und als Felder des Structure Arrays \texttt{params} übergeben. Für
jedes in dieser Arbeit dokumentierte Experiment verweisen wir in
\Cref{chap:experiments} an entsprechender Stelle auf das dafür benutzte 
Benchmark, welches in \texttt{./nonconforming/benchmarks/} zu finden ist und
somit die Reproduzierbarkeit des Experiments garantiert. 
Als Muster für eine Bechmark-Datei dient
\begin{center}
  \texttt{./nonconforming/benchmarks/editable.m}.
\end{center}
Eine Übersicht über die in einer Benchmark-Datei wählbaren Parameter ist
zu finden in den Tabellen \ref{tab:paramsMisc}, \ref{tab:paramsAFEM}, 
\ref{tab:paramsIteration}, \ref{tab:paramsExperiment} und \ref{tab:paramsDoc}
sowie über die definierbaren Funktion in \Cref{tab:paramsFunctions}.
Weitere Details zu den Datentypen sind in \texttt{editable.m} zu finden.

Dass die zahlreichen Parameter, die während des Pro\-gramm\-ab\-laufs
über- oder ausgegeben werden müssen, als Felder von
Struc\-ture Ar\-rays gespeichert werden, dient der Modifizierbarkeit des
Programms. 
So haben Korrekturen und Ergänzungen am Programm häufig nur zur Folge, dass
einige \texttt{structs} um Felder ergänzt werden müssen während die 
Methodenköpfe unverändert bleiben können.

Das Eingangssignal $f$ und eventuell weitere Funktionen, wie etwa die exakte
Lösung $u$ von \Cref{prob:continuousProblem} und ihre schwache Ableitung
$\nabla u$, müssen in der Benchmark-Datei angegeben werden, um sie dem
Programm zu übergeben. 
Die für die Experimente in \Cref{chap:experiments} genutzten Funktionen sind zu
finden in 
\begin{center}
  \texttt{./utils/functions/}.
\end{center}

Ist eine Lösung $u$ von $\Cref{prob:continuousProblem}$ bekannt, so kann die
exakte Energie $E(u)$ approximiert werden mit der Methode
\begin{center}
  \texttt{./nonconforming/computeExactEnergyBV.m}.
\end{center}
Die so berechneten Energien werden gespeichert im Ordner
\begin{center}
  \texttt{./nonconforming/knownExactEnergies/}
\end{center}
und können anschließend manuell in ein Benchmark aufgenommen werden.

Soll als Eingangssignal kein \texttt{function\_handle} sondern ein
Graufarbenbild gegeben werden, so muss es gespeichert sein in 
\begin{center}
  \texttt{./utils/functions/images/}.
\end{center}
Um Dirichlet-Nullranddaten des Bildes zu garantierten, was einem schwarzen Rand
entspricht, kann die Methode 
\begin{center}
  \texttt{./utils/functions/images/addBoundary2image.m}
\end{center}
genutzt werden. Diese fügt einen graduellen Übergang zu schwarzen Rand auf den 
äußeren 25 Pixeln des Bildes hinzu.

Um additives weißes gaußsches Rauschen zu einen Bild hinzuzufügen, kann die
Methode
\begin{center}
  \texttt{./utils/functions/images/addNoise2image.m}
\end{center}
genutzt werden. 

\begin{table}
  \centering
  \begin{tabular}{c|p{9cm}}
    \hline
    Parametername  & Beschreibung\\  
    \hline
    \texttt{showPlots} & \\
    \texttt{plotModeGrayscale} & \\
    \texttt{showProgress}& \\
    \texttt{degree4Integrate}& \\
    \texttt{plotGivenFunctions}&\\
    \texttt{refinementLevel4Plots}& \\
    \texttt{debugIfError}& \\
    \hline
  \end{tabular}
  \caption{Diverse Parameter zur Kontrolle des Programmablaufs}
  \label{tab:paramsMisc}
\end{table} 

\begin{table}
  \centering
  \begin{tabular}{c|p{9cm}}
    \hline
    Parametername  & Beschreibung\\  
    \hline
    \texttt{geometry} &
    Name der Geometrie auf deren Triangulierung der AFEM-Algorithmus
    angewendet werden soll 
    \newline(cf. \texttt{loadGeometry} in \cite{CGKNRR10})\\
    \texttt{initialRefinementLevel} &
    Anzahl der Rotverfeinerungen die auf die Triangulierung der Geometrie
    \texttt{geometry} angewendet werden sollen vor Start des AFEM\--Algorithmus 
    \newline(cf. \texttt{loadGeometry} in \cite[Abschnitt 1.9.1]{CGKNRR10})\\
    \texttt{parTheta}& Bulk-Parameter $\theta$ für den Mark-Schritt des
    AFEM-Algorithmus ($\theta\in(0,1)$ für adaptive und $\theta=1$ für uniforme
    Netzverfeinerung)\\
    \texttt{minNrDof}& 
    Anzahl der Freiheitsgrade der Triangulierung eines Levels, die mindestens
    erreicht werden soll, bevor der AFEM-Algorithmus abbricht\\
    \texttt{useProlongation}&
    \texttt{true}, wenn eine Prolongation der Lösung der pri\-ma\-len-dualen 
    Iteration als Startwert für die Iteration des nächsten Levels genutzt
    werden soll, sonst \texttt{false}\\
    \texttt{beta4Estimate}& 
    Parameter $\gamma$ aus \Cref{def:refinementIndicator}\\
    \texttt{n4Estimate}& 
    Parameter $d$ aus \Cref{def:refinementIndicator}\\
    \hline
  \end{tabular}
  \caption{Parameter für den AFEM-Algorithmus}
  \label{tab:paramsAFEM}
\end{table} 

\begin{table}
  \centering
  \begin{tabular}{c|p{9cm}}
    \hline
    Parametername  & Beschreibung\\  
    \hline
    \texttt{u0Mode} & \\
    \texttt{initialEpsStop} & \\
    %\texttt{stopCrit} & \\
    \texttt{parTau}& \\
    \hline
  \end{tabular}
  \caption{Parameter für die Einstellungen der Iteration}
  \label{tab:paramsIteration}
\end{table} 

\begin{table}
  \centering
  \begin{tabular}{c|p{9cm}}
    \hline
    Parametername  & Beschreibung\\  
    \hline
    \texttt{useImage} & \\
    \texttt{imageName} & \\
    \texttt{parAlpha}& \\
    \texttt{parBeta} & \\
    \texttt{rhsGradientKnown} & \\
    \texttt{exactSolutionKnown}& \\
    \texttt{useExactEnergy} & \\
    \texttt{exactEnergy} & \\
    %\texttt{saveScreenshots} & \\
    \hline
  \end{tabular}
  \caption{Parameter des Experiments}
  \label{tab:paramsExperiment}
\end{table} 

\begin{table}
  \centering
  \begin{tabular}{c|p{9cm}}
    \hline
    Parametername  & Beschreibung\\  
    \hline
    \texttt{expName} & \\
    \texttt{dirInfoName} & \\
    %\texttt{errorNorm}& \\
    \hline
  \end{tabular}
  \caption{Parameter zum Speichern der Ergebnisse}
  \label{tab:paramsDoc}
\end{table} 

\begin{table}
  \centering
  \begin{tabular}{c|p{9cm}}
    \hline
    Parametername  & Beschreibung\\  
    \hline
    \texttt{rightHandSide} & \\
    \texttt{gradientRightHandSide} & \\
    \texttt{exactSolution}& \\
    \hline
  \end{tabular}
  \caption{Definierbare \texttt{function\_handles}}
  \label{tab:paramsFunctions}
\end{table} 


\section{Programmablauf}
\label{sec:programFlow}

In diesen Abschnitt betrachten wir eine beispielhafte Ausführung des Programms,
bei der alle relevanten Methoden genutzt werden.

In der Benchmark-Datei für den Programmaufruf müssen, neben den Eingangssignal
$f\in H^1_0(\Omega)$, die Lösung $u\in H^1_0(\Omega)$, die exakte Energie
$E(u)$ und der schwache Gradient von $f$ gegeben sein. 
Damit diese Informationen tatsächlich genutzt werden, müssen zusätzlich einige
Parameter wie folgt gewählt werden.
\begin{itemize}
  \item \texttt{useExactEnergy = true}
  \item \texttt{useImage = false}
  \item \texttt{rhsGradientKnown = true}
  \item \texttt{exactSolutionKnown = true}
  \item \texttt{useExactEnergy = true}
\end{itemize}

Noch in der Benchmark-Datei werden mit den gewählten Einstellungen die
benötigten geometrischen Datenstrukturen initialisiert. 
Diese werden mit allen weiteren Informationen als Felder eines Structure Arrays
gespeichert und an \texttt{startAlgorithmCR} übergeben. 

Dort werden zunächst Structure Arrays mit Feldern für die benötigten Daten
während der AFEM-Routine sowie deren Ergebnisse erstellt. 
Nach dem Berechnen einiger weiterer Informationen beginnt die AFEM-Schleife.

Zu Beginn der Schleife werden die für das aktuelle Level benötigten Daten
ermittelt, zum Beispiel die Flächeninhalte der Dreiecke und die Freiheitsgrade
der aktuellen Triangulierung. 
Insbesondere werden die auf dem Level mehrmals benötigten Gradienten der
lokalen Crouzeix-Raviart-Basisfunktionen auf allen Dreiecken berechnet (cf.
\cite[Abschnitt 1.4.2]{CGKNRR10}) in
\begin{center}
  \texttt{./nonconforming/common/computeGradsCR4e.m}.
\end{center}
Mit diesen wird der stückweise Gradient des Startwerts $u_0$ aus
\Cref{alg:primalDualIteration} berechnet in
\begin{center}
  \texttt{./nonconforming/common/gradientCR.m}.
\end{center}
Mit $\gradnc u_0$ wird anschließend $\Lambda_0$ aus
\Cref{alg:primalDualIteration} auf allen $T\in\Tcal$ initialisiert als 
\begin{align*}
  \Lambda_0|_T\coloneqq
  \begin{cases}
    \frac{\nabla u_0|_T}{|\nabla u_0|_T|},&\text{falls }\nabla u_0|_T\neq 0,\\
    0,&\text{falls }\nabla u_0|_T= 0.
  \end{cases}
\end{align*}

Außerdem werden die Steifigkeits- und Massematrix aus
\Cref{rem:primalDualMatrixEquations} aufgestellt in
\begin{center}
  \texttt{./nonconforming/common/computeFeMatricesCR.m}.
\end{center}
Dabei benutzten wir für jedes $T\in\Tcal$, dass die lokale Massematrix auf
$T$ berechnet werden kann durch
\begin{align*}
  A_T
  =
  \frac{|T|}{3}I_3.
\end{align*}
Die Aufstellung der lokalen Steifigkeitsmatrizen sowie die Berechnung der
globalen Stei\-fig\-keits- und Massematrix aus ihren lokalen Versionen geschieht
analog zu \cite[Abschnitt 1.4.2]{CGKNRR10}).

Danach werden für jedes Dreieck $T\in\Tcal$ mit den 
lokalen Crouzeix-Raviart-Basis\-funk\-tio\-nen $\psi_{T,k}$, $k\in\{1,2,3\}$,
die Integrale $ \int_T f\psi_{T,k}\dx$ berechnet. 
Mit diesen wird außerdem für alle Crouzeix-Raviart-Basisfunktionen
$\psi_F$, $F\in\Ecal$, das Integral $\int_\Omega f\psi_F\dx$ berechnet.
Dies alles geschieht mithilfe der \texttt{integrate} Methode 
\cite[Abschnitt 1.8.2]{CGKNRR10} des AFEM-Softwarepakets in 
\begin{center}
  \texttt{./nonconforming/common/integralsWithF4e.m}.
\end{center}
\todo{Extra Section mit Details (insb wie die CR Funktionen dort implementiert
sind)?}

Damit sind alle notwendigen Daten ermittelt um die primale-duale Iteration 
zur Lösung auf dem Level zu starten. Genutzt wird dafür die Methode
\begin{center}
  \texttt{./nonconforming/main/solvePrimalDualFormulation.m}.
\end{center}
Details dazu diskutieren wir in \Cref{sec:implementationPrimalDualIteration}.

\bigskip output des level etc werden belegt

\bigskip
\begin{center}
  \texttt{./nonconforming/common/computeNormDiffRhsSolCrSquared4e.m}
\end{center}


\bigskip GLEB
\begin{center}
  \texttt{./nonconforming/common/computeGleb.m}
\end{center}

\bigskip  Verfeinerungsindikator, dafür zunächst (mit Verweis auf die section
dafür)
\begin{center}
  \texttt{./nonconforming/common/computeL1NormOfJump4s.m}
\end{center}
und dann 
\begin{center}
  \texttt{./nonconforming/estimate/estimateErrorCR4e.m}
\end{center}

\bigskip error nutzt \texttt{error4eCRL2} mit cite des Abschnitts in
\cite{CGKNRR10}.

\bigskip gebe information über das Level auf der Konsole aus und
speichere die Resulate

\bigskip checke termination crit

\bigskip mark (mit verweis auf genutzte Methode aus AFEM)

\bigskip refine (mit verweis auf genutzte Methode aus AFEM)

\bigskip prolongation (mit kurzer Erläuterung, mit welcher Idee die passiert)

auch darauf eingehen, wie u0 gewählt wird wenn keine Prolongation?

\bigskip polygonmesh ignorieren? 


\section{Realisierung der primalen-dualen Iteration}
\label{sec:implementationPrimalDualIteration}
In diesen Abschnitt beschreiben wir die Methode
\begin{center}
  \texttt{./nonconforming/main/solvePrimalDualFormulation.m}.
\end{center}
Dabei benutzen wir die Bezeichnungen aus \Cref{alg:primalDualIteration}, der
in dieser Methode realisiert wird.

Wie in \Cref{sec:programFlow} beschrieben, sind vor Aufruf von
\texttt{solvePrimalDualFormulation} bereits alle benötigten Informationen
über die aktuelle Triangulierung $\Tcal$ bekannt sowie
die Steifigkeits- und Massematix aus \Cref{rem:primalDualMatrixEquations} und
die Integrale $\int_\Omega f\psi_F\dx$ für alle
Crouzeix-Raviart-Basisfunktionen $\psi_F$, $F\in\Ecal$.

Mit der Steifigkeits- und Massematrix ist direkt ersichtlich,
wie die Koeffizientenmatrix des Gleichungssystems
\eqref{eq:linSysPrimalDualAlgMatrixEq} implementiert werden kann.
Für die Implementation der rechten Seite dieses Systems nutzten wir die
folgende Beobachtung.
Sei für alle $F\in\Ecal$ die Menge der Dreiecke in $\Tcal$, die $F$ als Kante
haben, gegeben durch $\Tcal(F)$. 
Für alle $k\in\{1,2,\cdots,|\Ecal|\}$ gilt damit, da $\gradnc u_{j-1}$,
$\Lambda_j$ und $\gradnc \psi_{E_k}$ stückweise konstant sind,
\begin{align*}
  \left(\frac{1}{\tau}\gradnc u_{j-1}-\Lambda_j,\gradnc\psi_{E_k}\right)
  &=
  \sum_{T\in\Tcal}
  \left(\frac{1}{\tau}\gradnc u_{j-1}-\Lambda_j,
  \gradnc\psi_{E_k}\right)_{L^2(T)}\\
  &=
  \sum_{T\in\Tcal(F)} |T|
  \frac{1}{\tau}\left(\gradnc u_{j-1}-\Lambda_j\right)\!|_T\cdot
  \nabla\psi_{E_k}|_T.
\end{align*}
Da die Terme
\begin{align*}
  \left(f,\psi_{E_k}\right)=\int_\Omega f\psi_{E_k}\dx
\end{align*}
bereits berechnet wurden, können wir somit die rechte Seite $\overline b$
implementieren.

Es ist direkt ersichtlich wie der verbleibende Teil von
\Cref{alg:primalDualIteration} implementiert werden kann.
Sonstige Informationen über die Iteration, wie etwa das Abbruchkriterium,
diskutieren wir in \Cref{chap:experiments}.

Es bleibt anzumerken, dass in \texttt{solvePrimalDualFormulation}, neben 
\Cref{alg:primalDualIteration}, der Ausgabe des Fortschritts sowie
der Übergabe von Ergebnissen der Iteration, auch die Berechnung der
nichtkonformen Energie $\Enc(u_j)$ der Iterate realisiert wird. 
Dies geschieht in der Methode
\begin{center}
  \texttt{./nonconforming/common/computeDiscreteEnergyCR.m}.
\end{center}
Dabei werden die Massematrix $M$ und die Integrale 
$\int_\Omega f\psi_{F}\dx$, $F\in\Ecal$, wie folgt genutzt.
Sei $\vcr\in\CR^1_0(\Tcal)$ und $v\in\Rbb^{|\Ecal|}$
enthalte die Koordinaten von $\vcr$ bezüglich der Basis
$\left\{\psi_{E_1},\psi_{E_2},\ldots,\psi_{E_{|\Ecal|}}\right\}$, das heißt
$\vcr=\sum_{k=1}^{|\Ecal|}v_k \psi_{E_k}$.
Dann gilt
\begin{align*}
  \Enc(\vcr)
  &=
  \frac{\alpha}{2}\Vert \vcr\Vert^2
  + \Vert\gradnc \vcr\Vert_{L^1(\Omega)}
  -\int_\Omega f\vcr\dx\\
  &=
  \frac{\alpha}{2}
  \sum_{k=1}^{|\Ecal|} 
  \sum_{\ell=1}^{|\Ecal|} 
  v_k\left( \psi_{E_k}, \psi_{E_\ell} \right)v_\ell
  + \sum_{T\in\Tcal}
   \int_T\left|\gradnc \vcr\right|\dx
  -\sum_{k=1}^{|\Ecal|}v_k\int_\Omega f\psi_{E_k}\dx\\
  &=
  \frac{\alpha}{2} v\cdot Mv
  + \sum_{T\in\Tcal}|T| \left|\gradnc \vcr\right|
  -\sum_{k=1}^{|\Ecal|}v_k\int_\Omega f\psi_{E_k}\dx.
\end{align*}



%cf Realisierungschapter PB
%
%Tabelle 4.2 (PB) artige Übersicht über die benutzten AFEM 
%Datenstrukturen, die im Programm nicht extra dokumentiert wurden. Für alle
%anderen In- und Outputs verweise auf Dokumentation in den Docstrings
%
%Die Ausführbare Funktionen werden im nächsten Kapitel beschrieben.
%
%%\subsection{Erstellen eines lauffähigen Benchmarks (Minimalbeispeil)}
%
%Wahrscheinlich flag für flag durchgehen, erklären, welche automatisch gesetzt 
%werden u.U., und wann immer nötig sagen, was man vorher machen muss, wo man
%Funktionen erstellen muss etc.
%
%fur exakte Lösungs Beispiel usw.
%Berechnung der exakten Energie, also alles was nur mehr Möglichkeiten bietet,
%Verweis auf die nächste Section (in der dann sagen, welche Flags gesetzt werden 
%können)


\section{Erstellen einer Benchmark-Datei}
Vielleicht (das heißt wahrscheinlich) in der 'Hinweise' Section in einer
Tabelle ala PB Realisierungstabelle. Tabellen vlt trennen nach Art der paramter
(AFEM Params, Exp Params, Funktionen, misc usw.)
Beispielhaft für eine der Parameter Arten machen um Tien fragen zu können

Datentypen weglassen mit Verweis auf Details in editable?
  %\begin{tabular}{c||p{4cm}|p{5cm}}
  %  \hline
  %  Parametername & Datentypen & Beschreibung\\  
  %  \hline
  %  \texttt{geometry} &
  %  \texttt{string} /\newline einzeiliges \texttt{char array} 
  %  & Name der Geometrie auf deren Triangulierung der AFEM-Algorithmus
  %  angewendet werden soll 
  %  \newline(cf. \texttt{loadGeometry} 
  %  \newline
  %  in \cite{CGKNRR10})\\
  %  \texttt{initialRefinementLevel} 
  %  &\texttt{uint64}
  %  &Anzahl der Rotverfeinerungen 
  %  \newline(cf. \texttt{loadGeometry} 
  %  \newline in \cite{CGKNRR10})\\
  %  \texttt{parTheta}&\texttt{double}\\
  %  \texttt{minNrDof}&\texttt{uint64}\\
  %  \texttt{useProlongation}&\texttt{logical}\\
  %  \texttt{beta4Estimate}&\texttt{double}\\
  %  \texttt{n4Estimate}&\texttt{uint64}\\
  %  \hline
  %\end{tabular}

Parameter weglassen die nicht garantiert geändert werden sollen/können ohne
Anpassungen des Programms?

\section{Mathematische Grundlagen ausgewählter Methoden}
\label{sec:mathematicalBasicsForMethods}


\subsection{Berechnung lokaler Knotenwerte einer Crouzeix-Raviart-Funktion}

Sei $\ucr\in\CR^1(\Tcal)$.

Für die in dieser Arbeit implementierte Prolongation von $\ucr$ auf eine
Verfeinerung der Triangulierung $\Tcal$ oder für die Berechnung der $L^1$-Norm
der Kantensprünge von $\ucr$ benötigen wir für jedes Dreieck $T\in\Tcal$ die
Werte von $\ucr$ in den Knoten von $T$. 

Dazu sei $T = \conv\{P_1, P_2, P_3\}$ mit den Kanten
$E_1 = \conv\{P_1,P_2\}$, $E_2 = \conv\{P_2,P_3\}$ und $E_3 =
\conv\{P_3,P_1\}$. 
Die Funktion $u\coloneqq\ucr|_T$ habe in den Mittelpunkten der Kanten die Werte
$u_j\coloneqq u\left(\Mid(E_j)\right)$ für alle $j\in\{1,2,3\}$. 
Gesucht sind damit die Werte $u(P_1)$, $u(P_2)$ und $u(P_3)$.

Da $\ucr\in\CR^1(\Tcal)$, ist $u$ affin. Damit gilt für eine Kante
$E=\conv\{P,Q\}\in\{E_1,E_2,E_3\}$, dass $u(\Mid(E))$ gegeben ist durch den
Mittelwert von $u(P)$ und $u(Q)$.

Somit erhalten wir die drei Gleichungen
\begin{align*}
  u_1 &= \frac{u(P_1)+u(P_2)}{2},  
  &u_2 &= \frac{u(P_2)+u(P_3)}{2},  
  &u_3 &= \frac{u(P_3)+u(P_1)}{2}.
\end{align*}
Sind $u_1$, $u_2$ und $u_3$ bekannt, können wir dieses Gleichungssystem nach 
$u(P_1)$, $u(P_2)$ und $u(P_3)$ lösen und erhalten die gesuchten Werte
\begin{align*}
 u(P_1)&=u_1+u_3-u_2, &u(P_2)&= u_1+u_2-u_3,&u(P_3)&=u_2+u_3-u_1.
\end{align*}

Wir realisieren dies mit der Methode
\begin{center}
  \texttt{./nonconforming/common/computeNodeValuesCR4e.m}.
\end{center} 

\subsection{Berechnung von Sprungtermen}

Insbesondere für die Berechnung des Verfeinerungsindikators aus
\Cref{def:refinementIndicator} benötigen wir eine Methode, die
für eine Crouzeix-Raviart-Funktion
$\vcr\in\CR^1_0(\Tcal)$
%und zur Auswertung der kontinuierlichen Energie $E(\vcr)$ einer 
%Crouzeix-Raviart Funktion $\vcr$, deren diskrete Energie $\Enc(\vcr)$
%bereits bekannt ist, 
für alle Kanten $F\in\Ecal$ die Terme $\Vert [\vcr]_F\Vert_{L^1(F)}$ 
bestimmt.

Da $\vcr\in\CR^1_0(\Tcal)$, ist $[\vcr]_F$ affin und es gilt
$[\vcr]_F\big(\Mid(F)\big)=0$ für alle Kanten $F\in\Ecal$.

Betrachten wir nun eine beliebige Kante $F\in\Ecal$ mit $F=\conv\{P_1,P_2\}$. 
Wir definieren eine Parametrisierung $\xi:[0,2]\to\Rbb^2$ von $F$ durch
$\xi(t)\coloneqq \frac{t}{2}(P_2-P_1)+P_1$. 
Es gilt $\left|\xi'\right|\equiv \frac{1}{2}|P_2-P_1|=\frac{1}{2}|F|$.

Sei außerdem
$p(t)\coloneqq [\vcr]_F\big(\xi(t)\big)$. Dann gilt
\begin{align*}
  \Vert [\vcr]_F\Vert_{L^1(F)} 
  &=
  \int_F |[\vcr]_F|\ds 
  = \int_0^2 |p(t)|\left|\xi'(t)\right|\dt
  = \frac{|F|}{2}\int_0^2 |p(t)|\dt\\
  &= \frac{|F|}{2}\left(\int_0^1 |p(t)|\dt + \int_1^2 |p(t)|\dt\right).
\end{align*}

Da $\vcr\in\CR^1_0(\Tcal)$, ist $|p(\bullet)|$ auf $[0,1]$ und $[1,2]$ jeweils
ein Polynom von Grad $1$ mit $|p(1)|=\left|[\vcr]_F\big(\Mid(F)\big)\right|=0$. 
Somit können wir $|p|$ explizit ausdrücken durch
\begin{align*}
  |p(t)|&=(1-t)|p(0)| \quad\text{für alle }t\in[0,1] \quad\text{und }\\
  |p(t)|&=(t-1)|p(2)| \quad\text{für alle }t\in[1,2].
\end{align*}
Damit erhalten wir, aufgrund der Exaktheit der Mittelpunktsregel für Polynome
von Grad 1, dass
\begin{align*}
  \int_0^1 |p(t)|\dt 
  &= 
  (1-0)\left|p\left( \frac{1}{2} \right)\right|
  =
  \frac{|p(0)|}{2}\quad\text{und }\\
  \int_1^2 |p(t)|\dt 
  &= 
  (2-1)\left|p\left( \frac{3}{2} \right)\right|
  =
  \frac{|p(2)|}{2}.
\end{align*}

Insgesamt gilt also
\begin{align*}
  \left\Vert [\vcr]_F\right\Vert_{L^1(F)} 
  &=
  \frac{|F|}{2}\left(\frac{|p(0)|}{2} + \frac{|p(2)|}{2}\right)
  =
  \frac{|F|}{4}\big(|p(0)|+|p(2)|\big)\\
  &= 
  \frac{|F|}{4}\big(|[\vcr]_F(P_1)|+|[\vcr]_F(P_2)|\big),
\end{align*}
beziehungsweise 
  $\Vert [\vcr]_F\Vert_{L^1(F)} =
  \frac{|F|}{4}\big(|\vcr(P_1)|+|\vcr(P_2)|\big)$ für eine Randkanten
  $F\in\Ecal(\partial\Omega)$.

Realisiert wird dies in der Methode
\begin{center}
  \texttt{./nonconforming/common/computeL1NormOfJump4s.m}.
\end{center}
Dabei werden für $\vcr\in\CR^1_0(\Tcal)$ für jede Kante $F\in\Ecal$ mit
$F=\conv\{P_1,P_2\}$ die Terme $|[\vcr]_F(P_1)|$ und $|[\vcr]_F(P_2)|$
berechnet in
\begin{center}
  \texttt{./nonconforming/common/computeAbsNodeJumps4s.m}.
\end{center}


\subsection{Implementation der GLEB}
\begin{center}
  \texttt{./nonconforming/common/computeGleb.m}.
\end{center}

\subsection{Implementation des Refinement Indicators}

\subsection{Implementaition der exakten Energie Berechnung}


