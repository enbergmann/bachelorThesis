\section{Hinweise zur Benutzung des Programms}
%\subsection{Aufbau des Programms}
Ziel der für diese Arbeit implementierten Methoden ist die Realisierung von
\Cref{alg:primalDualIteration} im Solve-Schritt des AFEM-Algorithmus aus
\Cref{fig:afemLoop}. 
Wir gehen davon aus, dass dieser und die im
AFEM-Softwarepaket realisierten Methoden sowie deren Datenstrukturen bekannt
sind und verweisen für weitere Details auf \cite{CGKNRR10}.

\begin{figure}[h]
  \centering
  \input{pictures/chapImplementation/afemloop.tex}
  \caption{AFEM-Schleife}
  \label{fig:afemLoop}
\end{figure}

Die zur korrekten Funktionsweise dieses Programms nötigen Methoden und
Dateien des AFEM-Softwarepakets sind enthalten im Ordner
\texttt{./utils/afemPackage/} sowie \texttt{./utils/geometries/}.

Alle Ein- und Ausgabeparameter der im Rahmen dieser Arbeit implementierten
Methoden sind in den entsprechenden Dateien detailiert dokumentiert. 
Ausgenommen davon sind die Standard-Datenstrukturen aus dem AFEM-Softwarepaket,
die dort lediglich namentlich genannt werden.
Die mathematischen Grundlagen für die Realisierung einiger Methoden diskutieren
wir in \Cref{sec:mathematicalBasicsForMethods}.

Die ausführbare Methode, welche den AFEM-Algorithmus realisiert, ist
\begin{center}
  \texttt{./nonconforming/startAlgorithmCR.m}.
\end{center}
Als optionaler Eingabeparameter ist dabei ein String \texttt{benchmark}
möglich. 
Wird die Methode ohne Übergabe eines solchen Parameters ausgeführt, nutzt
sie als Standardwert \texttt{benchmark = 'editable'}.
Nach Ausführen von \texttt{startAlgorithmCR(benchmark)} werden die nötigen
Parameter und Einstellungen für das jeweilige Experiment aus der Datei
\begin{center}
  \texttt{./nonconforming/benchmarks/benchmark.m}
\end{center}
geladen und als Felder des Structure Arrays \texttt{params} übergeben. Für
jedes in dieser Arbeit dokumentierte Experiment verweisen wir in
\Cref{chap:experiments} an entsprechender Stelle auf das dafür benutzte 
Benchmark, welches in \texttt{./nonconforming/benchmarks/} zu finden ist und
somit die Reproduzierbarkeit des Experiments garantiert. Als Muster für 
eine Bechmark-Datei dient
\begin{center}
  \texttt{./nonconforming/benchmarks/editable.m}.
\end{center}
In dieser Datei sind auch die wählbaren Parameter und Einstellungen
dokumentiert.
\todo{alle Benchmark einstellungen hier in einer Tabelle auflisten und
dokumentieren? Wahrscheinlich ja, so kann dokumentiert werden, dass zB 
Prolongation möglich ist. ``Alle Einstellungen und Paramter dokumentieren wir
in Abschnitt \ldots''. Dort kann dann auch, vlt auch erst wenn CC das will,
gesagt werden zB sowas wie prolongiert wird}

Dass die zahlreichen Parameter, die während des Pro\-gramm\-ab\-laufs
über- oder ausgegeben werden müssen, als Felder von
Struc\-ture Ar\-rays gespeichert werden, dient der Modifizierbarkeit des
Programms. 
So haben Korrekturen und Ergänzungen am Programm häufig nur zur Folge, dass
einige \texttt{structs} um Felder ergänzt werden müssen während die 
Methodenköpfe unverändert bleiben können.

Das Eingangssignal $f$ und eventuell weitere Funktionen, wie etwa die exakte
Lösung $u$ von \Cref{prob:continuousProblem} und ihre schwache Ableitung
$\nabla u$, welche in einer Benchmark-Datei angegeben werden müssen um sie dem
Programm zu übergeben, sind zu finden in 
\begin{center}
  \texttt{./utils/functions/}.
\end{center}

Ist eine Lösung $u$ von $\Cref{prob:continuousProblem}$ bekannt, so kann die
exakte Energie $E(u)$ approximiert werden mit der Methode
\begin{center}
  \texttt{./nonconforming/computeExactEnergyBV.m}.
\end{center}
Die so berechneten Energien werden gespeichert in 
\begin{center}
  \texttt{./nonconforming/knownExactEnergies/}
\end{center}
und können anschließend manuell in ein Benchmark aufgenommen werden.
\todo{$f=\alpha g$ und weiter Details zur Umwandlung von Bildern? Hier oder
bei Details zu ausgewählten Funktionen?}

Soll als Eingangssignal kein \texttt{function\_handle} sondern ein
Graufarbenbild gegeben werden, so muss es gespeichert sein in 
\begin{center}
  \texttt{./utils/functions/images/}.
\end{center}
Um Dirichlet-Nullranddaten des Bildes zu garantierten, was einem schwarzen Rand
entspricht, kann die Methode 
\begin{center}
  \texttt{./utils/functions/images/addBoundary2image.m}
\end{center}
genutzt werden. Diese fügt einen graduellen Übergang zu schwarzen Rand auf den 
äußeren 25 Pixeln des Bildes hinzu.

Um additives weißes gaußsches Rauschen zu einen Bild hinzuzufügen, kann die
Methode
\begin{center}
  \texttt{./utils/functions/images/addNoise2image.m}
\end{center}
genutzt werden. 

%\bigskip
%%%%%%%%%%%%%%%%%%%%%%%%%%
%cd Realisierungschapter PB
%
%Tabelle 4.2 (PB) artige Übersicht über die benutzten AFEM 
%Datenstrukturen, die im Programm nicht extra dokumentiert wurden. Für alle
%anderen In- und Outputs verweise auf Dokumentation in den Docstrings
%
%
%
%Die Ausführbare Funktionen werden im nächsten Kapitel beschrieben.
%
%%\subsection{Erstellen eines lauffähigen Benchmarks (Minimalbeispeil)}
%Beschreibung der wichtigsten Parameter
%und Idee hinter structs
%
%Ordner, in denen die Funktionen für rechte Seite, Gradient, exakte
%Lösung etc liegen müsssen
%
%Wahrscheinlich flag für flag durchgehen, erklären, welche automatisch gesetzt 
%werden u.U., und wann immer nötig sagen, was man vorher machen muss, wo man
%Funktionen erstellen muss etc.
%
%fur exakte Lösungs Beispiel usw.
%Berechnung der exakten Energie, also alles was nur mehr Möglichkeiten bietet,
%Verweis auf die nächste Section (in der dann sagen, welche Flags gesetzt werden 
%können)
%
%
%\subsubsection{\texttt{startAlgorithmCR.m}}
%\texttt{test}
%\subsubsection{\texttt{computeExactEnergyBV.m}}
%\subsubsection{\texttt{addNoise2image.m}}
%\subsubsection{\texttt{addBoundary2image.m}}


\section{Erstellen einer Benchmark-Datei}
Vielleicht (das heißt wahrscheinlich) in der 'Hinweise' Section in einer
Tabelle ala PB Realisierungstabelle. Tabellen vlt trennen nach Art der paramter
(AFEM Params, Exp Params, Funktionen, misc usw.)
Beispielhaft für eine der Paramter Arten machen um Tien fragen zu können


\section{Mathematische Grundlagen ausgewählter Funktionen}
\label{sec:mathematicalBasicsForMethods}
\todo{Funktionsname in den Sections als Überschrift oder Nutzen der 
entsprechenden Methode in die Überschrift?}


\subsection{\texttt{computeNodeValuesCR4e}}

Sei $\ucr\in\CR^1(\Tcal)$.

Für die in dieser Arbeit implementierte Prolongation von $\ucr$ auf eine
Verfeinerung der Triangulierung $\Tcal$ oder für die Berechnung der $L^1$-Norm
der Kantensprünge von $\ucr$ benötigen wir für jedes Dreieck $T\in\Tcal$ die
Werte von $\ucr$ in den Knoten von $T$. 
Diese berechnen wir mit der Methode
\begin{center}
  \texttt{./nonconforming/common/computeNodeValuesCR4e.m}
\end{center} 

Dazu sei $T = \conv\{P_1, P_2, P_3\}$ mit den Kanten
$E_1 = \conv\{P_1,P_2\}$, $E_2 = \conv\{P_2,P_3\}$ und $E_3 =
\conv\{P_3,P_1\}$. 
Die Funktion $u\coloneqq\ucr|_T$ habe in den Mittelpunkten der Kanten die Werte
$u_j\coloneqq u\left(\Mid(E_j)\right)$ für alle $j\in\{1,2,3\}$. 
Gesucht sind damit die Werte $u(P_1)$, $u(P_2)$ und $u(P_3)$.

Da $\ucr\in\CR^1(\Tcal)$, ist $u$ affin-linear. Damit gilt für eine Kante
$E=\conv\{P,Q\}\in\{E_1,E_2,E_3\}$, dass $u(\Mid(E))$ gegeben ist durch den
Mittelwert von $u(P)$ und $u(Q)$.

Somit erhalten wir die drei Gleichungen
\begin{align*}
  u_1 &= \frac{u(P_1)+u(P_2)}{2},  
  &u_2 &= \frac{u(P_2)+u(P_3)}{2},  
  &u_3 &= \frac{u(P_3)+u(P_1)}{2}.
\end{align*}
Sind $u_1$, $u_2$ und $u_3$ bekannt, können wir dieses Gleichungssystem nach 
$u(P_1)$, $u(P_2)$ und $u(P_3)$ lösen und erhalten die gesuchten Werte
\begin{align*}
 u(P_1)&=u_1+u_3-u_2, &u(P_2)&= u_1+u_2-u_3,&u(P_3)&=u_2+u_3-u_1.
\end{align*}


\subsection{Berechnung der L1 Norm der Sprünge}
\todo{hier}
Für die Berechnung des Verfeinerungsindikators [verweis auf entsprechende
section] und zur Auswertung der kontinuierlichen Energie $E(\vcr)$ einer 
Crouzeix-Raviart Funktion $\vcr$, deren diskrete Energie $\Enc(\vcr)$
bereits bekannt ist, werden die $L^1$ Normen der Kantensprünge 
$[\vcr]_F$ für alle Kanten $F\in\Fcal$ der Triangulierung benötigt,
wobei für eine Innenkante $F\in\Fcal(\Omega)$, die gemeinsame Kante der
Dreiecke $T_+$ und $T_-$ ist, gilt
$[\vcr]_F\coloneqq (\vcr|_{T_+})|_F-(\vcr|_{T_-})|_F$
und $[\vcr]_F \coloneqq \vcr|_F$ für eine Randkante
$F\in\Fcal(\partial\Omega)$. Die Konvention der Wahl von
$T_+$ und $T_-$ ist hier irrelevant, da wir
zur Berechung von $\Vert [\vcr]_F\Vert_{L^1(\Omega)}$
ausschließlich den Betrag $|[\vcr]_F|$ benötigen.

Da $\vcr\in\CR^1(\Tcal)$,
ist $[\vcr]_F$ affin linear und es gilt $[\vcr]_F(\Mid(F))=0$ für 
alle Innenkanten $F\in\Fcal(\Omega)$ und, falls 
$\vcr\in\CR^1_0(\Tcal)$, auch für alle Randkanten $F\in\Fcal(\partial\Omega)$.

Die folgenden Aussagen gelten also für Innenkanten beliebiger
Crouzeix-Raviart Funktionen, wir beschränken uns aber von nun
an auf Funktionen $\vcr\in\CR^1_0(\Tcal)$.

Betrachten wir also eine beliebige Kante $F\in\Fcal$
mit $F=\conv\{P_1,P_2\}$. 
Wir definieren eine Parametrisierung $\gamma:[0,2]\to\Rbb^2$ von $F$ durch
$\gamma(t)\coloneqq \frac{t}{2}(P_2-P_1)+P_1$. 
Es gilt $|\gamma'|\equiv \frac{1}{2}|P_2-P_1|=\frac{1}{2}|F|$.

Sei außerdem
$p(t)\coloneqq [\vcr]_F(\gamma(t))$. Dann gilt nach
 [cite Wegintegrale] 
\begin{align*}
  \Vert [\vcr]_F\Vert_{L^1(F)} 
  &=
  \int_F |[\vcr]_F|\ds 
  = \int_0^2 |p(t)|\,|\gamma'(t)|\dt
  = \frac{|F|}{2}\int_0^2 |p(t)|\dt\\
  &= \frac{|F|}{2}\left(\int_0^1 |p(t)|\dt + \int_1^2 |p(t)|\dt\right).
\end{align*}

Da $\vcr\in\CR^1_0(\Tcal)$, ist $|p|$ auf $[0,1]$ und $[1,2]$ jeweils
ein Polynom
vom Grad $1$ mit $p(1)=[\vcr]_F(\Mid(F))=0$, womit sich $|p|$ jeweils
explizit ausdrücken lässt durch
$|p|(t)=(1-t)|p|(0)$ für alle $t\in[0,1]$ und 
$|p|(t)=(t-1)|p|(2)$ für alle $t\in[1,2]$.
Die Mittelpunktsregel $\int_a^b f(x)\dx\approx (b-a)f( (a+b)/2)$ [cite] ist
exakt für Polynome vom Grad $1$ und somit gilt
\begin{align*}
  \int_0^1 |p(t)|\dt 
  &= 
  (1-0)|p|\left( \frac{1}{2} \right)
  =
  \frac{|p|(0)}{2}\quad\text{und }\\
  \int_1^2 |p(t)|\dt 
  &= 
  (2-1)|p|\left( \frac{3}{2} \right)
  =
  \frac{|p|(2)}{2}.
\end{align*}

Somit erhalten wir insgesamt 
\begin{align*}
  \Vert [\vcr]_F\Vert_{L^1(F)} 
  &=
  \frac{|F|}{2}\left(\frac{|p|(0)}{2} + \frac{|p|(2)}{2}\right)
  =
  \frac{|F|}{4}(|p|(0)+|p|(2))\\
  &= 
  \frac{|F|}{4}\big(|[\vcr]_F|(P_1)+|[\vcr]_F|(P_2)\big),
\end{align*}
beziehungsweise 
  $\Vert [\vcr]_F\Vert_{L^1(F)} =
  \frac{|F|}{4}\big(|\vcr|(P_1)+|\vcr|(P_2)\big)$ für eine Randkanten
  $F\in\Fcal(\partial\Omega)$.

Diese Berechnung ist realisiert durch die 
Funktionen \texttt{computeBlaJumps}, die die absoluten Sprünge
in den Endpunkte einer Kante berchnet, \texttt{computeAbsJumps}, die \ldots,
und \texttt{computeL1NormOfJumps}, die schließlich die $L^1$ Norm aller
Kantensprünge berechnet\ldots.



\subsection{Implementation der GLEB}

\subsection{Implementation des Refinement Indicators}

\subsection{Implementaition der exakten Energie Berechnung}


