\section{Hinweise zur Benutzung des Programms}
%\subsection{Aufbau des Programms}
Ziel der für diese Arbeit implementierten Methoden ist die Realisierung von
\Cref{alg:primalDualIteration} im Solve-Schritt des AFEM-Algorithmus aus
\Cref{fig:afemLoop}. 
Wir gehen davon aus, dass dieser und die im
AFEM-Softwarepaket realisierten Methoden sowie deren Datenstrukturen bekannt
sind und verweisen für weitere Details auf \cite{CGKNRR10}. 
Im Refine-Schritt nutzten wir anstelle eines Fehlerschätzers den
Verfeinerungsindikator aus \Cref{def:refinementIndicator}.

\begin{figure}[h]
  \centering
  \input{pictures/chapImplementation/afemloop.tex}
  \caption{AFEM-Schleife}
  \label{fig:afemLoop}
\end{figure}

Die zur korrekten Funktionsweise dieses Programms nötigen Methoden und
Dateien des AFEM-Softwarepakets sind enthalten in den Ordnern
\begin{center}
    \texttt{./utils/afemPackage/} sowie \texttt{./utils/geometries/}.
\end{center}

Alle Ein- und Ausgabeparameter der im Rahmen dieser Arbeit implementierten
Methoden sind in den entsprechenden Dateien detailiert dokumentiert. 
Ausgenommen davon sind die Standard-Datenstrukturen aus dem AFEM-Softwarepaket,
die dort lediglich namentlich genannt werden.
Die mathematischen Grundlagen für die Realisierung einiger Methoden diskutieren
wir in \Cref{sec:mathematicalBasicsForMethods}.

Die ausführbare Methode, welche den AFEM-Algorithmus realisiert, ist
\begin{center}
  \texttt{./nonconforming/startAlgorithmCR.m}.
\end{center}
Als optionaler Eingabeparameter ist dabei ein String \texttt{benchmark}
möglich. 
Wird die Methode ohne Übergabe eines solchen Parameters ausgeführt, nutzt
sie als Standardwert \texttt{benchmark = 'editable'}.
Nach Ausführen von \texttt{startAlgorithmCR(benchmark)} werden die nötigen
Parameter und Einstellungen für das jeweilige Experiment aus der Datei
\begin{center}
  \texttt{./nonconforming/benchmarks/benchmark.m}
\end{center}
geladen und als Felder des Structure Arrays \texttt{params} übergeben. Für
jedes in dieser Arbeit dokumentierte Experiment verweisen wir in
\Cref{chap:experiments} an entsprechender Stelle auf das dafür benutzte 
Benchmark, welches in \texttt{./nonconforming/benchmarks/} zu finden ist und
somit die Reproduzierbarkeit des Experiments garantiert. 
Als Muster für eine Bechmark-Datei dient
\begin{center}
  \texttt{./nonconforming/benchmarks/editable.m}.
\end{center}
Eine Übersicht über die in einer Benchmark-Datei wählbaren Parameter ist
zu finden in den Tabellen \ref{tab:paramsMisc}, \ref{tab:paramsAFEM}, 
\ref{tab:paramsIteration}, \ref{tab:paramsExperiment} und \ref{tab:paramsDoc}
sowie über die definierbaren Funktion in \Cref{tab:paramsFunctions}.
Details zu den Datentypen sind in \texttt{editable.m} aufgeführt.

Dass die zahlreichen Parameter, die während des Pro\-gramm\-ab\-laufs
über- oder ausgegeben werden müssen, als Felder von
Struc\-ture Ar\-rays gespeichert werden, dient der Modifizierbarkeit des
Programms. 
So haben Korrekturen und Ergänzungen am Programm häufig nur zur Folge, dass
einige \texttt{structs} um Felder ergänzt werden müssen während die 
Methodenköpfe unverändert bleiben können.

Das Eingangssignal $f$ und eventuell weitere Funktionen, wie etwa die exakte
Lösung $u$ von \Cref{prob:continuousProblem} und ihre schwache Ableitung
$\nabla u$, müssen in der Benchmark-Datei angegeben werden, um sie dem
Programm zu übergeben. 
Die für die Experimente in \Cref{chap:experiments} genutzten Funktionen sind zu
finden in 
\begin{center}
  \texttt{./utils/functions/}.
\end{center}

Ist eine Lösung $u$ von $\Cref{prob:continuousProblem}$ bekannt, so kann die
exakte Energie $E(u)$ approximiert werden mit der Methode
\begin{center}
  \texttt{./nonconforming/computeExactEnergyBV.m}.
\end{center}
Die so berechneten Energien werden gespeichert im Ordner
\begin{center}
  \texttt{./nonconforming/knownExactEnergies/}
\end{center}
und können anschließend manuell in ein Benchmark aufgenommen werden.

Soll als Eingangssignal kein \texttt{function\_handle} sondern ein
Graufarbenbild gegeben werden, so muss es gespeichert sein in 
\begin{center}
  \texttt{./utils/functions/images/}.
\end{center}
Um Dirichlet-Nullranddaten des Bildes zu garantierten, was einem schwarzen Rand
entspricht, kann die Methode 
\begin{center}
  \texttt{./utils/functions/images/addBoundary2image.m}
\end{center}
genutzt werden. Diese fügt einen graduellen Übergang zu schwarzen Rand auf den 
äußeren 25 Pixeln des Bildes hinzu.

Um additives weißes gaußsches Rauschen zu einen Bild hinzuzufügen, kann die
Methode
\begin{center}
  \texttt{./utils/functions/images/addNoise2image.m}
\end{center}
genutzt werden. 

\begin{table}
  \centering
  \begin{tabular}{c|p{9cm}}
    \hline
    Parametername  & Beschreibung\\  
    \hline
    \texttt{showPlots} 
    & \texttt{true}, wenn während des Programmablaufs Plots angezeigt werden
    sollen, sonst \texttt{false}\\
    \texttt{plotModeGrayscale} 
    & \texttt{true}, wenn während des Programmablaufs Plots von Funktionen
    als Graufarbenbilder angezeigt werden sollen, sonst \texttt{false} 
    (Wahl irrelevant, wenn \texttt{showPlots == false})\\
    \texttt{showProgress}
    & \texttt{true}, wenn während der primalen-dualen Iteration Information
    über den aktuellen Iterationsschritt angezeigt werden sollen, sonst
    \texttt{false} \\
    \texttt{degree4Integrate}
    & algebraischer Exaktheitsgrad für Aufrufe der Methode \texttt{in\-tegrate} 
    \cite[Abschnitt 1.8.2]{CGKNRR10} des AFEM-Soft\-ware\-pakets\\
    \texttt{plotGivenFunctions}
    & \texttt{true}, wenn Plots des Eingangssignals $f$ und, falls angegeben,
    der Lösung $u$ von \Cref{prob:continuousProblem} erstellt und gespeichert
    werden sollen, sonst \texttt{false}\\
    \texttt{refinementLevel4Plots}
    & Anzahl der Rotverfeinerungen der geladenen Geometrie um Plots des
    Eingangssignal $f$ und, falls angegeben, der Lösung $u$ von
    \Cref{prob:continuousProblem} zu erstellen (Wahl irrelevant, falls
    \texttt{plotGivenFunctions == false})\\
    \texttt{debugIfError}
    & \texttt{true}, wenn Matlab beim Auftreten eines Fehlers den Debug-Modus
    starten soll, sonst \texttt{false}\\
    \hline
  \end{tabular}
  \caption{Diverse Parameter zur Kontrolle des Programmablaufs}
  \label{tab:paramsMisc}
\end{table} 

\begin{table}
  \centering
  \begin{tabular}{c|p{9cm}}
    \hline
    Parametername  & Beschreibung\\  
    \hline
    \texttt{geometry} &
    Name der Geometrie auf deren Triangulierung der AFEM-Algorithmus
    angewendet werden soll 
    \newline(cf. \texttt{loadGeometry} in \cite[Abschnitt 1.9.1]{CGKNRR10})\\
    \texttt{initialRefinementLevel} &
    Anzahl der Rotverfeinerungen die auf die Triangulierung der Geometrie
    \texttt{geometry} angewendet werden sollen vor Start des AFEM\--Algorithmus 
    \newline(cf. \texttt{loadGeometry} in \cite[Abschnitt 1.9.1]{CGKNRR10})\\
    \texttt{parTheta}& Bulk-Parameter $\theta$ für den Mark-Schritt des
    AFEM-Algorithmus ($\theta\in(0,1)$ für adaptive und $\theta=1$ für uniforme
    Netzverfeinerung)\\
    \texttt{minNrDof}& 
    Anzahl der Freiheitsgrade der Triangulierung eines Levels, die mindestens
    erreicht werden soll, bevor der AFEM-Algorithmus abbricht\\
    \texttt{useProlongation}&
    \texttt{true}, wenn eine Prolongation der Lösung der pri\-ma\-len-dualen 
    Iteration als Startwert für die Iteration des nächsten Levels genutzt
    werden soll, sonst \texttt{false}\\
    \texttt{beta4Estimate}& 
    Parameter $\gamma$ aus \Cref{def:refinementIndicator}\\
    \texttt{n4Estimate}& 
    Parameter $d$ aus \Cref{def:refinementIndicator} (muss für diese 
    Implementierung stets 2 sein)\\
    \hline
  \end{tabular}
  \caption{Parameter für den AFEM-Algorithmus}
  \label{tab:paramsAFEM}
\end{table} 

\begin{table}
  \centering
  \begin{tabular}{c|p{9cm}}
    \hline
    Parametername  & Beschreibung\\  
    \hline
    \texttt{u0Mode} 
    & Startwert $u_0$ für \Cref{alg:primalDualIteration} auf dem ersten Level
    und, falls \texttt{useProlongation == true}, für die Iteration auf allen
    Level der AFEM-Routine (\texttt{'zeroes'} für $u_0=0$ und
    \texttt{'interpolationRhs'}, falls für $u_0$ die nichtkonforme Interpolation
    des Eingangssignals $f$ genutzt werden soll)\\
    \texttt{initialEpsStop} & Parameter $\epsstop$ für das Abbruchkriterium
    aus \Cref{chap:experiments}\\
    %\texttt{stopCrit} & \\
    \texttt{parTau}& Parameter $\tau$ aus \Cref{alg:primalDualIteration}\\
    \hline
  \end{tabular}
  \caption{Parameter für die Einstellungen der Iteration}
  \label{tab:paramsIteration}
\end{table} 

\begin{table}
  \centering
  \begin{tabular}{c|p{9cm}}
    \hline
    Parametername  & Beschreibung\\  
    \hline
    \texttt{useImage} & \\
    \texttt{imageName} & \\
    \texttt{parAlpha}& \\
    \texttt{parBeta} & \\
    \texttt{rhsGradientKnown} & \\
    \texttt{exactSolutionKnown}& \\
    \texttt{useExactEnergy} & \\
    \texttt{exactEnergy} & \\
    %\texttt{saveScreenshots} & \\
    \hline
  \end{tabular}
  \caption{Parameter des Experiments}
  \label{tab:paramsExperiment}
\end{table} 

\begin{table}
  \centering
  \begin{tabular}{c|p{9cm}}
    \hline
    Parametername  & Beschreibung\\  
    \hline
    \texttt{expName} & \\
    \texttt{dirInfoName} & \\
    %\texttt{errorNorm}& \\
    \hline
  \end{tabular}
  \caption{Parameter zum Speichern der Ergebnisse}
  \label{tab:paramsDoc}
\end{table} 

\begin{table}
  \centering
  \begin{tabular}{c|p{9cm}}
    \hline
    Parametername  & Beschreibung\\  
    \hline
    \texttt{rightHandSide} & \\
    \texttt{gradientRightHandSide} & \\
    \texttt{exactSolution}& \\
    \hline
  \end{tabular}
  \caption{Definierbare \texttt{function\_handles}}
  \label{tab:paramsFunctions}
\end{table} 


\section{Programmablauf}
\label{sec:programFlow}

In diesen Abschnitt betrachten wir eine beispielhafte Ausführung des Programms,
bei der alle relevanten Methoden genutzt werden.

In der Benchmark-Datei für den Programmaufruf müssen, neben den Eingangssignal
$f\in H^1_0(\Omega)$, die Lösung $u\in H^1_0(\Omega)$, die exakte Energie
$E(u)$ und der schwache Gradient von $f$ gegeben sein. 
Damit diese Informationen tatsächlich genutzt werden, müssen zusätzlich einige
Parameter wie folgt gewählt werden.
\begin{itemize}
  \item \texttt{useExactEnergy = true}
  \item \texttt{useImage = false}
  \item \texttt{rhsGradientKnown = true}
  \item \texttt{exactSolutionKnown = true}
  \item \texttt{useExactEnergy = true}
\end{itemize}

Noch in der Benchmark-Datei werden mit den gewählten Einstellungen die
benötigten geometrischen Datenstrukturen initialisiert. 
Diese werden mit allen weiteren Informationen als Felder eines Structure Arrays
gespeichert und an \texttt{startAlgorithmCR} übergeben. 

Dort werden zunächst Structure Arrays mit Feldern für die benötigten Daten
während der AFEM-Routine sowie deren Ergebnisse erstellt. 
Nach dem Berechnen einiger weiterer Informationen beginnt die AFEM-Schleife.

Zu Beginn der Schleife werden die für das aktuelle Level benötigten Daten
ermittelt, zum Beispiel die Flächeninhalte der Dreiecke und die Freiheitsgrade
der aktuellen Triangulierung. 
Insbesondere werden die auf dem Level mehrmals benötigten Gradienten der
lokalen Crouzeix-Raviart-Basisfunktionen auf allen Dreiecken berechnet (cf.
\cite[Abschnitt 1.4.2]{CGKNRR10}) in
\begin{center}
  \texttt{./nonconforming/common/computeGradsCR4e.m}.
\end{center}
Mit diesen wird der stückweise Gradient des Startwerts $u_0$ aus
\Cref{alg:primalDualIteration} berechnet in
\begin{center}
  \texttt{./nonconforming/common/gradientCR.m}.
\end{center}
Mit $\gradnc u_0$ wird anschließend $\Lambda_0$ aus
\Cref{alg:primalDualIteration} auf allen $T\in\Tcal$ initialisiert als 
\begin{align*}
  \Lambda_0|_T\coloneqq
  \begin{cases}
    \frac{\nabla u_0|_T}{|\nabla u_0|_T|},&\text{falls }\nabla u_0|_T\neq 0,\\
    0,&\text{falls }\nabla u_0|_T= 0.
  \end{cases}
\end{align*}

Außerdem werden die Steifigkeits- und Massematrix aus
\Cref{rem:primalDualMatrixEquations} aufgestellt in
\begin{center}
  \texttt{./nonconforming/common/computeFeMatricesCR.m}.
\end{center}
Dabei benutzten wir für jedes $T\in\Tcal$, dass die lokale Massematrix auf
$T$ berechnet werden kann durch
\begin{align*}
  A_T
  =
  \frac{|T|}{3}I_3.
\end{align*}
Die Aufstellung der lokalen Steifigkeitsmatrizen sowie die Berechnung der
globalen Stei\-fig\-keits- und Massematrix aus ihren lokalen Versionen geschieht
analog zu \cite[Abschnitt 1.4.2]{CGKNRR10}).

Danach werden in
\begin{center}
  \texttt{./nonconforming/common/integralsWithF4e.m}
\end{center}
mit den Crouzeix-Raviart-Basisfunktionen
$\psi_F$, $F\in\Ecal$, für jedes Dreieck $T\in\Tcal$ mit Kanten
$\Ecal(T)=\{E_1,E_2,E_3\}$ die Integrale $\int_T f\psi_{E_k}\!|_T\dx$,
$k\in\{1,2,3\}$, berechnet. 
Dies geschieht mithilfe der \texttt{integrate} Methode \cite[Abschnitt
1.8.2]{CGKNRR10} des AFEM-Softwarepakets.
Die Berechnung der dafür benötigten lokalen Crouzeix-Raviart-Basisfunktionen
$\psi_{E_k}\!|_T$, $k\in\{1,2,3\}$ diskutieren wir in
\Cref{sec:localCRBasisRealization}.
Anschließend kann für alle $F\in\Ecal$ auch das Integral 
\begin{align*}
  \int_\Omega f\psi_F\dx
  &=
  \sum_{T\in\Tcal}\int_T f\psi_F\!|_T\dx
  =
  \sum_{T\in\Tcal(F)}\int_T f\psi_F\!|_T\dx
\end{align*}
bestimmt werden.

Damit sind alle notwendigen Daten ermittelt um die primale-duale Iteration 
zur Lösung auf dem Level zu starten. Genutzt wird dafür die Methode
\begin{center}
  \texttt{./nonconforming/main/solvePrimalDualFormulation.m}.
\end{center}
Details dazu diskutieren wir in \Cref{sec:implementationPrimalDualIteration}.

\todo{hier}

\bigskip output des level etc werden belegt

\bigskip
\begin{center}
  \texttt{./nonconforming/common/computeNormDiffRhsSolCrSquared4e.m}
\end{center}


\bigskip GLEB
\begin{center}
  \texttt{./nonconforming/common/computeGleb.m}
\end{center}

\bigskip  Verfeinerungsindikator, dafür zunächst (mit Verweis auf die section
dafür)
\begin{center}
  \texttt{./nonconforming/common/computeL1NormOfJump4s.m}
\end{center}
und dann 
\begin{center}
  \texttt{./nonconforming/estimate/estimateErrorCR4e.m}
\end{center}

\bigskip error nutzt \texttt{error4eCRL2} mit cite des Abschnitts in
\cite{CGKNRR10}.

\bigskip gebe information über das Level auf der Konsole aus und
speichere die Resulate

\bigskip checke termination crit

\bigskip mark (mit verweis auf genutzte Methode aus AFEM)

\bigskip refine (mit verweis auf genutzte Methode aus AFEM)

\bigskip prolongation (mit kurzer Erläuterung, mit welcher Idee die passiert)

auch darauf eingehen, wie u0 gewählt wird wenn keine Prolongation?

insbesondere auch auf interpolationCR noch kurz eingehen

\bigskip polygonmesh ignorieren? 


\section{Realisierung der primalen-dualen Iteration}
\label{sec:implementationPrimalDualIteration}
In diesen Abschnitt beschreiben wir die Methode
\begin{center}
  \texttt{./nonconforming/main/solvePrimalDualFormulation.m}.
\end{center}
Dabei benutzen wir die Bezeichnungen aus \Cref{alg:primalDualIteration}, der
in dieser Methode realisiert wird.

Wie in \Cref{sec:programFlow} beschrieben, sind vor Aufruf von
\texttt{solvePrimalDualFormulation} bereits alle benötigten Informationen
über die aktuelle Triangulierung $\Tcal$ bekannt sowie
die Steifigkeits- und Massematix aus \Cref{rem:primalDualMatrixEquations} und
die Integrale $\int_\Omega f\psi_F\dx$ für alle
Crouzeix-Raviart-Basisfunktionen $\psi_F$, $F\in\Ecal$.

Mit der Steifigkeits- und Massematrix ist direkt ersichtlich,
wie die Koeffizientenmatrix des Gleichungssystems
\eqref{eq:linSysPrimalDualAlgMatrixEq} implementiert werden kann.
Für die Implementation der rechten Seite dieses Systems nutzten wir die
folgende Beobachtung.
Für alle $k\in\{1,2,\cdots,|\Ecal|\}$ gilt, da $\gradnc u_{j-1}$,
$\Lambda_j$ und $\gradnc \psi_{E_k}$ stückweise konstant sind,
\begin{align*}
  \left(\frac{1}{\tau}\gradnc u_{j-1}-\Lambda_j,\gradnc\psi_{E_k}\right)
  &=
  \sum_{T\in\Tcal}
  \left(\frac{1}{\tau}\gradnc u_{j-1}-\Lambda_j,
  \gradnc\psi_{E_k}\right)_{L^2(T)}\\
  &=
  \sum_{T\in\Tcal(E_k)} |T|
  \frac{1}{\tau}\left(\gradnc u_{j-1}-\Lambda_j\right)\!|_T\cdot
  \nabla\psi_{E_k}|_T.
\end{align*}
Da die Terme $\left(f,\psi_{E_k}\right)=\int_\Omega f\psi_{E_k}\dx$ bereits
berechnet wurden, können wir somit die rechte Seite $\overline b$
implementieren.

Es ist direkt ersichtlich wie der verbleibende Teil von
\Cref{alg:primalDualIteration} implementiert werden kann.
Sonstige Informationen über die Iteration, wie etwa das Abbruchkriterium,
diskutieren wir in \Cref{chap:experiments}.

Es bleibt anzumerken, dass in \texttt{solvePrimalDualFormulation}, neben 
\Cref{alg:primalDualIteration}, der Ausgabe des Fortschritts sowie
der Übergabe von Ergebnissen der Iteration, auch die
nichtkonformen Energien $\Enc(u_j)$ der Iterate berechnet werden. 
Diese Berechnung ist realisiert in
\begin{center}
  \texttt{./nonconforming/common/computeDiscreteEnergyCR.m}.
\end{center}
Dabei werden die Massematrix $M$ und die Integrale 
$\int_\Omega f\psi_{F}\dx$, $F\in\Ecal$, wie folgt genutzt.
Sei $\vcr\in\CR^1_0(\Tcal)$ und $v\in\Rbb^{|\Ecal|}$
enthalte die Koordinaten von $\vcr$ bezüglich der Basis
$\left\{\psi_{E_1},\psi_{E_2},\ldots,\psi_{E_{|\Ecal|}}\right\}$, das heißt
$\vcr=\sum_{k=1}^{|\Ecal|}v_k \psi_{E_k}$.
Dann gilt
\begin{align*}
  \Enc(\vcr)
  &=
  \frac{\alpha}{2}\Vert \vcr\Vert^2
  + \Vert\gradnc \vcr\Vert_{L^1(\Omega)}
  -\int_\Omega f\vcr\dx\\
  &=
  \frac{\alpha}{2}
  \sum_{k=1}^{|\Ecal|} 
  \sum_{\ell=1}^{|\Ecal|} 
  v_k\left( \psi_{E_k}, \psi_{E_\ell} \right)v_\ell
  + \sum_{T\in\Tcal}
   \int_T\left|\gradnc \vcr\right|\dx
  -\sum_{k=1}^{|\Ecal|}v_k\int_\Omega f\psi_{E_k}\dx\\
  &=
  \frac{\alpha}{2} v\cdot Mv
  + \sum_{T\in\Tcal}|T| \left|\gradnc \vcr\right|
  -\sum_{k=1}^{|\Ecal|}v_k\int_\Omega f\psi_{E_k}\dx.
\end{align*}


\section{Mathematische Grundlagen ausgewählter Methoden}
\label{sec:mathematicalBasicsForMethods}


\subsection{Berechnung lokaler Crouzeix-Raviart-Basisfunktionen}
\label{sec:localCRBasisRealization}

In der Methode
\begin{center}
  \texttt{./nonconforming/common/integralsWithF4e.m}
\end{center}
werden auf allen Dreiecken der Triangulierung die lokalen
Crouzeix-Raviart-Basis\-funk\-tio\-nen benötigt. Die Berechnung dieser geschieht 
im Programm wie folgt.

Sei $T\in\Tcal$ mit $T=\conv\left(\{P_1,P_2,P_3\}\right)$. Zunächst bestimmen
wir die baryzentrischen Koordinaten $\lambda_j\in P_1(T)$, $j\in\{1,2,3\}$,
die für $j,k\in\{1,2,3\}$ charakterisiert sind durch
\begin{align*}
  \lambda_j(P_k)
  =
  \begin{cases}
    1,&\text{falls }  j=k,\\
    0,&\text{sonst.}
  \end{cases}
\end{align*}
Dafür betrachten wir das Referenzdreieck, das 
definiert ist durch
\begin{align*}
  \Tref \coloneqq
  \conv\left(\left\{
  \begin{pmatrix}
   1\\0 
  \end{pmatrix},
  \begin{pmatrix}
   0\\1 
  \end{pmatrix},
  \begin{pmatrix}
   0\\0 
  \end{pmatrix}
  \right\}\right),
\end{align*}
und, mit der Matrix $B\coloneqq (P_1-P_3,P_2-P_3)$, die affine Transformation
$p:\Tref \to T$, $x \mapsto Bx+P_3$. 
Mithilfe der Umkehrabbildung von $p$, die gegeben ist durch $p^{-1}:T\to\Tref$,
$x\mapsto B^{-1}(x-P_3)$, können die baryzentrischen Koordinaten für alle $x\in
T$ berechnet werden durch 
\begin{align*}
  \begin{pmatrix}
    \lambda_1(x)\\
    \lambda_2(x)
  \end{pmatrix}
  &=
  p^{-1}(x) &&\text{und}
  &\lambda_3(x)
  &=1-\lambda_1(x)-\lambda_2(x).
\end{align*}

Seien die Kanten $E_1,E_2$ und $E_3$ von $T$ nun so gewählt, dass für
$j\in\{1,2,3\}$ die Kante $E_j$ gegenüber von $P_j$ liegt. 
Dann können wir die lokale Crouzeix-Raviart-Basisfunktionen 
$\psi_{E_j}\!|_T$, $j\in\{1,2,3\}$, für alle $x\in T$ berechnen durch
$\psi_{E_j}\!|_T(x)=1-2\lambda_j(x)$.


\subsection{Berechnung lokaler Knotenwerte einer Crouzeix-Raviart-Funktion}

Sei $\vcr\in\CR^1(\Tcal)$.

Für die in dieser Arbeit implementierte Prolongation von $\vcr$ auf eine
Verfeinerung der Triangulierung $\Tcal$ oder für die Berechnung der $L^1$-Norm
der Kantensprünge von $\vcr$ benötigen wir für jedes Dreieck $T\in\Tcal$ die
Werte von $\vcr$ in den Knoten von $T$. 

Dazu sei $T = \conv\{P_1, P_2, P_3\}$ mit den Kanten
$E_1 = \conv\{P_1,P_2\}$, $E_2 = \conv\{P_2,P_3\}$ und $E_3 =
\conv\{P_3,P_1\}$. 
Die Funktion $v\coloneqq\vcr|_T$ habe in den Mittelpunkten der Kanten die Werte
$v_j\coloneqq v\left(\Mid(E_j)\right)$ für alle $j\in\{1,2,3\}$. 
Gesucht sind damit die Werte $v(P_1)$, $v(P_2)$ und $v(P_3)$.

Da $\vcr\in\CR^1(\Tcal)$, ist $v$ affin. Damit gilt für eine Kante
$E=\conv\{P,Q\}\in\{E_1,E_2,E_3\}$, dass $v(\Mid(E))$ gegeben ist durch den
Mittelwert von $v(P)$ und $v(Q)$.

Somit erhalten wir die drei Gleichungen
\begin{align*}
  v_1 &= \frac{v(P_1)+v(P_2)}{2},  
  &v_2 &= \frac{v(P_2)+v(P_3)}{2},  
  &v_3 &= \frac{v(P_3)+v(P_1)}{2}.
\end{align*}
Sind $v_1$, $v_2$ und $v_3$ bekannt, können wir dieses Gleichungssystem nach 
$v(P_1)$, $v(P_2)$ und $v(P_3)$ lösen und erhalten die gesuchten Werte
\begin{align*}
 v(P_1)&=v_1+v_3-v_2, &v(P_2)&= v_1+v_2-v_3,&v(P_3)&=v_2+v_3-v_1.
\end{align*}

Wir realisieren dies mit der Methode
\begin{center}
  \texttt{./nonconforming/common/computeNodeValuesCR4e.m}.
\end{center} 

\subsection{Berechnung von Sprungtermen}

Insbesondere für die Berechnung des Verfeinerungsindikators aus
\Cref{def:refinementIndicator} benötigen wir eine Methode, die
für eine Crouzeix-Raviart-Funktion
$\vcr\in\CR^1_0(\Tcal)$
%und zur Auswertung der kontinuierlichen Energie $E(\vcr)$ einer 
%Crouzeix-Raviart Funktion $\vcr$, deren diskrete Energie $\Enc(\vcr)$
%bereits bekannt ist, 
für alle Kanten $F\in\Ecal$ die Terme $\Vert [\vcr]_F\Vert_{L^1(F)}$ 
bestimmt.

Da $\vcr\in\CR^1_0(\Tcal)$, ist $[\vcr]_F$ affin und es gilt
$[\vcr]_F\big(\Mid(F)\big)=0$ für alle Kanten $F\in\Ecal$.

Betrachten wir nun eine beliebige Kante $F\in\Ecal$ mit $F=\conv\{P_1,P_2\}$. 
Wir definieren eine Parametrisierung $\xi:[0,2]\to\Rbb^2$ von $F$ durch
$\xi(t)\coloneqq \frac{t}{2}(P_2-P_1)+P_1$. 
Es gilt $\left|\xi'\right|\equiv \frac{1}{2}|P_2-P_1|=\frac{1}{2}|F|$.

Sei außerdem
$p(t)\coloneqq [\vcr]_F\big(\xi(t)\big)$. Dann gilt
\begin{align*}
  \Vert [\vcr]_F\Vert_{L^1(F)} 
  &=
  \int_F |[\vcr]_F|\ds 
  = \int_0^2 |p(t)|\left|\xi'(t)\right|\dt
  = \frac{|F|}{2}\int_0^2 |p(t)|\dt\\
  &= \frac{|F|}{2}\left(\int_0^1 |p(t)|\dt + \int_1^2 |p(t)|\dt\right).
\end{align*}

Da $\vcr\in\CR^1_0(\Tcal)$, ist $|p(\bullet)|$ auf $[0,1]$ und $[1,2]$ jeweils
ein Polynom von Grad $1$ mit $|p(1)|=\left|[\vcr]_F\big(\Mid(F)\big)\right|=0$. 
Somit können wir $|p|$ explizit ausdrücken durch
\begin{align*}
  |p(t)|&=(1-t)|p(0)| \quad\text{für alle }t\in[0,1] \quad\text{und }\\
  |p(t)|&=(t-1)|p(2)| \quad\text{für alle }t\in[1,2].
\end{align*}
Damit erhalten wir, aufgrund der Exaktheit der Mittelpunktsregel für Polynome
von Grad 1, dass
\begin{align*}
  \int_0^1 |p(t)|\dt 
  &= 
  (1-0)\left|p\left( \frac{1}{2} \right)\right|
  =
  \frac{|p(0)|}{2}\quad\text{und }\\
  \int_1^2 |p(t)|\dt 
  &= 
  (2-1)\left|p\left( \frac{3}{2} \right)\right|
  =
  \frac{|p(2)|}{2}.
\end{align*}

Insgesamt gilt also
\begin{align*}
  \left\Vert [\vcr]_F\right\Vert_{L^1(F)} 
  &=
  \frac{|F|}{2}\left(\frac{|p(0)|}{2} + \frac{|p(2)|}{2}\right)
  =
  \frac{|F|}{4}\big(|p(0)|+|p(2)|\big)\\
  &= 
  \frac{|F|}{4}\big(|[\vcr]_F(P_1)|+|[\vcr]_F(P_2)|\big),
\end{align*}
beziehungsweise 
  $\Vert [\vcr]_F\Vert_{L^1(F)} =
  \frac{|F|}{4}\big(|\vcr(P_1)|+|\vcr(P_2)|\big)$ für eine Randkanten
  $F\in\Ecal(\partial\Omega)$.

Realisiert wird dies in der Methode
\begin{center}
  \texttt{./nonconforming/common/computeL1NormOfJump4s.m}.
\end{center}
Dabei werden für $\vcr\in\CR^1_0(\Tcal)$ für jede Kante $F\in\Ecal$ mit
$F=\conv\{P_1,P_2\}$ die Terme $|[\vcr]_F(P_1)|$ und $|[\vcr]_F(P_2)|$
berechnet in
\begin{center}
  \texttt{./nonconforming/common/computeAbsNodeJumps4s.m}.
\end{center}


\subsection{Implementation der GLEB}
\begin{center}
  \texttt{./nonconforming/common/computeGleb.m}.
\end{center}

\subsection{Implementation des Refinement Indicators}

\subsection{Implementaition der exakten Energie Berechnung}


